% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fast_mnn.R
\name{fast_mnn}
\alias{fast_mnn}
\title{Fast mutual nearest neighbors correction}
\usage{
fast_mnn(
  x,
  batch = NULL,
  norm.args = list(),
  assay.type = "counts",
  subset.row = NULL,
  d = 50L,
  k = 20L,
  prop.k = NULL,
  min.mean = 1L,
  weights = NULL,
  restrict = NULL,
  ndist = 3L,
  merge.order = NULL,
  auto.merge = FALSE,
  min.batch.skip = 0L,
  deferred = TRUE,
  BSPARAM = BiocSingular::IrlbaParam(),
  BNPARAM = BiocNeighbors::AnnoyParam(),
  BPPARAM = BiocParallel::SerialParam()
)
}
\arguments{
\item{x}{A single
\link[SingleCellExperiment:SingleCellExperiment]{SingleCellExperiment} object.}

\item{batch}{A factor specifying the batch of origin for all cells when only a single object is supplied in \code{...}.
This is ignored if multiple objects are present.}

\item{norm.args}{A named list of further arguments to pass to \code{\link[scuttle]{logNormCounts}}.}

\item{assay.type}{A string specifying which assay values contains the counts.}

\item{subset.row}{A vector specifying which features used to run
\link[batchelor:multiBatchPCA]{multiBatchPCA}.}

\item{d}{An integer scalar specifying the number of dimensions to keep from the PCA.
Alternatively \code{NA}, in which case the PCA step is omitted entirely - see details below.}

\item{k}{An integer scalar specifying the number of nearest neighbors to consider when identifying MNNs.}

\item{prop.k}{A numeric scalar in (0, 1) specifying the proportion of cells in each dataset to use for mutual nearest neighbor searching.
If set, the number of nearest neighbors used for the MNN search in each batch is redefined as \code{max(k, prop.k*N)} where \code{N} is the number of cells in that batch.}

\item{min.mean}{A numeric scalar specifying the minimum (library size-adjusted) average count of genes to be used for normalization.}

\item{weights}{Numeric vector, logical scalar or list specifying the weighting scheme to use, see below for details.}

\item{restrict}{A list of length equal to the number of objects in \code{...}.
Each entry of the list corresponds to one batch and specifies the cells to use when computing the correction.}

\item{ndist}{A numeric scalar specifying the threshold beyond which neighbours are to be ignored when computing correction vectors.
Each threshold is defined as a multiple of the number of median distances.}

\item{merge.order}{An integer vector containing the linear merge order of batches in \code{...}.
Alternatively, a list of lists representing a tree structure specifying a hierarchical merge order.}

\item{auto.merge}{Logical scalar indicating whether to automatically identify the \dQuote{best} merge order.}

\item{min.batch.skip}{Numeric scalar specifying the minimum relative magnitude of the batch effect, 
below which no correction will be performed at a given merge step.}

\item{deferred}{A logical scalar used to overwrite the \code{deferred} status of \code{BSPARAM} for greater speed.
Set to \code{NULL} to use the supplied status in \code{BSPARAM} directly.}

\item{BSPARAM}{A \link[BiocSingular:BiocSingularParam]{BiocSingularParam} object
specifying the algorithm to use for PCA in
\link[batchelor:multiBatchPCA]{multiBatchPCA}.}

\item{BNPARAM}{A \link[BiocNeighbors:BiocNeighborParam]{BiocNeighborParam} object
specifying the nearest neighbor algorithm.}

\item{BPPARAM}{A \link[BiocParallel:BiocParallelParam-class]{BiocParallelParam} object
specifying whether the PCA and nearest-neighbor searches should be
parallelized.}
}
\value{
A \code{SingleCellExperiment} objects with normalized log-expression
values in the "multiBatchNorm" assay (depending on values in norm.args). A
"PCA" matrix in the \code{reducedDims} slot, containing the first d PCs returned
by \code{multiBatchPCA} for each cell. A "corrected" matrix in the \code{reducedDims}
slot, containing corrected low-dimensional coordinates for each cell.
}
\description{
Correct for batch effects in single-cell expression data using a fast version
of the mutual nearest neighbors (MNN) method. This is similar with
\link[batchelor:fastMNN]{fastMNN}, but use
\link[batchelor:multiBatchNorm]{multiBatchNorm} to normalize differences in
sequencing depth rather than \link[batchelor:cosineNorm]{cosineNorm}.
}
\details{
This function provides a variant of the \link[batchelor:fastMNN]{fastMNN}
function, modified for simplicity
In particular:
\itemize{
\item It performs a batch normalization via
\link[batchelor:multiBatchNorm]{multiBatchNorm}.

\item It performs a multi-sample PCA via
\link[batchelor:multiBatchPCA]{multiBatchPCA} and subsequently performs all
calculations in the PC space.  This reduces computational work and provides
some denoising for improved neighbour detection.  As a result, though, the
corrected output cannot be interpreted on a gene level and is useful only for
cell-level comparisons, e.g., clustering and visualization.

\item The correction vector for each cell is directly computed from its
\code{k} nearest neighbours in the same batch.  Specifically, only the
\code{k} nearest neighbouring cells that \emph{also} participate in MNN pairs
are used.  Each MNN-participating neighbour is weighted by distance from the
current cell, using a tricube scheme with bandwidth equal to the median
distance multiplied by \code{ndist}.  This ensures that the correction vector
only uses information from the closest cells, improving the fidelity of local
correction.

\item Issues with \dQuote{kissing} are avoided with a two-step procedure that
removes variation along the batch effect vector.  First, the average
correction vector across all MNN pairs is computed.  Cell coordinates are
adjusted such that all cells in a single batch have the same position along
this vector.  The correction vectors are then recalculated with the adjusted
coordinates (but the same MNN pairs).
}

The \code{batch} argument allows users to easily perform batch correction
when all cells have already been combined into a single object.  This avoids
the need to manually split the matrix or SingleCellExperiment object into
separate objects for input into \code{fastMNN}.  In this situation, the order
of input batches is defined by the order of levels in \code{batch}.
}
\note{
\itemize{
\item \url{https://support.bioconductor.org/p/127544/#127553}
\item \url{https://github.com/MarioniLab/FurtherMNN2018/issues/6}
\item \url{https://support.bioconductor.org/p/9145895/#9145905}
Just a note for self-usage, from above threads, I preferred to re-run
\code{fast_mnn} after subsetting large cell sets (subset epithelium from all cell
types), for sub-clustering in smaller cell sets (subset a specific T cell
type from all T cells ).
}
}
\examples{
d1 <- matrix(rnbinom(50000, mu = 10, size = 1), ncol = 100)
d2 <- matrix(rnbinom(20000, mu = 50, size = 1), ncol = 40)
sce <- SingleCellExperiment::SingleCellExperiment(
    list(counts = cbind(d1, d2))
)
sce$batch <- rep(c("a", "b"), c(100L, 40L))
out <- fast_mnn(sce, batch = sce$batch)
# Corrected values for use in clustering, etc.
str(SingleCellExperiment::reducedDim(out))
# Extracting corrected expression values for gene 10.
summary(SummarizedExperiment::assay(out)[10, ])
}
\seealso{
\itemize{
\item \link[batchelor:multiBatchNorm]{multiBatchNorm}
\item \link[batchelor:multiBatchPCA]{multiBatchPCA}
\item \link[batchelor:reducedMNN]{reducedMNN}
}
}
