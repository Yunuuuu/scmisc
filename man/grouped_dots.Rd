% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grouped_dots.R
\name{grouped_dots}
\alias{grouped_dots}
\alias{plot_grouped_dots}
\alias{plot_grouped_dots,ANY-method}
\alias{plot_grouped_dots,SummarizedExperiment-method}
\title{Plot dots heatmap of group-level expression averages}
\usage{
plot_grouped_dots(x, ...)

\S4method{plot_grouped_dots}{ANY}(
  x,
  marker_list = NULL,
  cluster2cell = NULL,
  groups = NULL,
  ...,
  blocks = NULL,
  colour = color,
  color = NULL,
  center = FALSE,
  scale = FALSE,
  threshold = 0L,
  zlim = NULL,
  flip = FALSE,
  slice_border_gp = gpar(lwd = 0.5),
  row_labels = NULL,
  column_labels = NULL
)

\S4method{plot_grouped_dots}{SummarizedExperiment}(
  x,
  ...,
  groups = NULL,
  blocks = NULL,
  assay.type = "logcounts",
  swap_rownames = NULL
)
}
\arguments{
\item{x}{A numeric matrix of counts with cells in columns and features in
rows.

Alternatively, a
\link[SummarizedExperiment:RangedSummarizedExperiment-class]{SummarizedExperiment} or
\link[SingleCellExperiment:SingleCellExperiment]{SingleCellExperiment} object
containing such a matrix.}

\item{...}{Other arguments passed to \link{DotsHeatmap} and specific methods.}

\item{marker_list}{A named list contaning the markers for each cell types.
names indicate the cell type label and values indicate the markers for this
cell type. If NULL, defaults to all features in \strong{x}.}

\item{cluster2cell}{A named character or factor returned by
\code{\link[=annotate_clusters]{annotate_clusters()}}.}

\item{groups}{A factor (or vector coercible into a factor) specifying the
group to which each cell in \code{x} belongs. Alternatively, if \code{x} is a
\link[SingleCellExperiment:SingleCellExperiment]{SingleCellExperiment}, e.g,
String specifying the field of \code{colData(x)} containing the grouping factor.
In this way, if groups is \code{NULL}, "label" in \code{colData(x)} will be
extracted.}

\item{blocks}{A factor (or vector coercible into a factor) specifying the
blocking factor to which each cell in \code{x} belongs (e.g., batch of origin).
Alternatively, if \code{x} is a
\link[SummarizedExperiment:RangedSummarizedExperiment-class]{SummarizedExperiment}, e.g,
String specifying the field of \code{colData(x)} containing the grouping factor.
In this way, if clusters is \code{NULL}, "label" in \code{colData(x)} will be
extracted.}

\item{colour}{Alias for color.}

\item{color}{A vector of colours specifying the palette to use for increasing expression. 
This defaults to \link[viridis]{viridis} if \code{center=FALSE}, and the the \code{"RdYlBu"}
color palette from \code{\link[RColorBrewer]{brewer.pal}} otherwise.}

\item{center}{A logical scalar indicating whether each feature should have its mean expression 
(specifically, the mean of averages across all groups) centered at zero prior to plotting.}

\item{scale}{A logical scalar specifying whether each row should have its
average expression values scaled to unit variance prior to plotting.}

\item{threshold}{Numeric value specifying the cap on the proportion of
detected expression values.}

\item{zlim}{A numeric vector of length 2, specifying the upper and lower bounds for color mapping of expression values.
Values outside this range are set to the most extreme color.
If \code{NULL}, it defaults to the range of the expression matrix.
If \code{center=TRUE}, this defaults to the range of the centered expression matrix, made symmetric around zero.}

\item{flip}{A scalar logical indicates whether flipping the axis, the default
\code{FALSE} means rows are \code{features} specified in \code{marker_list} and columns
are \code{groups}.}

\item{slice_border_gp}{Graphic parameters for drawing slice rectangles. The
value should be specified by \link[grid:gpar]{gpar} and fill parameter is
always setted to "transparent". If \code{NULL}, no slice border will be drawn.}

\item{row_labels, column_labels}{The row and column labels of the heatmap. Can
be One of:
\itemize{
\item \code{NULL} for the default labels. If flip is \code{FALSE}, row_labels are the
same with \code{unlist(marker_list)} and the column_labels are the same with
\code{levels(groups)}. Otherwise, the reverse is also true.
\item A character vector of labels. If named, they will be matched by indexing
with the default labels, Otherwise, used as it is.
\item A function that takes the default labels as input and returns a character
vector of the same length. Can be also a rlang
\link[rlang:as_function]{lambda} function notation.
}}

\item{assay.type}{A string or integer scalar indicating which \code{assays} in the
\code{x} contains the count matrix.}

\item{swap_rownames}{A characters (or vector coercible into a characters)
used to identify features instead of \code{rownames(x)} when labelling plot
elements.  Alternatively, if \code{x} is a
\link[SummarizedExperiment:RangedSummarizedExperiment-class]{SummarizedExperiment}, e.g,
String specifying the field of \code{rowData(x)} to be used.}
}
\value{
A \link{DotsHeatmap} Object
}
\description{
\code{plot_grouped_dots} create a dot plot of expression values for a grouping of
cells, where the size and color of each dot represents the proportion of
detected expression values and the average expression, respectively, for each
feature in each group of cells.

The order of the row or column will be the same with \code{unlist(marker_list)} or
\code{levels(groups)} depend on whether flip is \code{TRUE} or \code{FALSE} if
ComplexHeatmap clustering is turned off (if groups isn't a factor, the
internal will coerce it as a factor). So we can easily add annotation in
Heatmap as long as we provide a
\link[ComplexHeatmap:HeatmapAnnotation]{HeatmapAnnotation} in the same order.
}
